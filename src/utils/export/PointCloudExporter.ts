/**
 * Point Cloud Export Utilities
 * Based on OpenCV and Python point cloud export techniques
 * Supports multiple formats: PLY, PCD, XYZ, CSV, OBJ
 * Integrates with COLMAP reconstruction pipeline
 */

export interface Point3D {
  x: number
  y: number
  z: number
  r?: number // 0-255
  g?: number // 0-255
  b?: number // 0-255
  nx?: number // Normal X
  ny?: number // Normal Y
  nz?: number // Normal Z
  intensity?: number
  confidence?: number
}

export interface ExportOptions {
  format: 'ply' | 'pcd' | 'xyz' | 'csv' | 'obj' | 'las'
  includeColors: boolean
  includeNormals: boolean
  includeIntensity: boolean
  precision: number
  coordinateSystem: 'opengl' | 'opencv' | 'colmap'
  compression?: 'none' | 'gzip' | 'binary'
  maxPoints?: number
  decimationFactor?: number
}

export interface ExportResult {
  success: boolean
  filePath?: string
  fileSize: number
  pointCount: number
  processingTime: number
  format: string
  error?: string
}

export class PointCloudExporter {
  private worker: Worker | null = null

  constructor() {
    this.initializeWorker()
  }

  private initializeWorker() {
    const workerCode = `
      // Web Worker for point cloud processing and export
      class PointCloudProcessor {
        static exportToPLY(points, options) {
          const { includeColors, includeNormals, precision } = options
          let header = \`ply
format ascii 1.0
comment Generated by COLMAP 3D Reconstruction Platform
element vertex \${points.length}
property float x
property float y
property float z\`

          if (includeColors) {
            header += \`
property uchar red
property uchar green
property uchar blue\`
          }

          if (includeNormals) {
            header += \`
property float nx
property float ny
property float nz\`
          }

          header += \`
end_header
\`

          let content = header
          points.forEach(point => {
            let line = \`\${point.x.toFixed(precision)} \${point.y.toFixed(precision)} \${point.z.toFixed(precision)}\`
            
            if (includeColors && point.r !== undefined) {
              line += \` \${Math.round(point.r)} \${Math.round(point.g)} \${Math.round(point.b)}\`
            }
            
            if (includeNormals && point.nx !== undefined) {
              line += \` \${point.nx.toFixed(precision)} \${point.ny.toFixed(precision)} \${point.nz.toFixed(precision)}\`
            }
            
            content += line + '\\n'
          })

          return content
        }

        static exportToPCD(points, options) {
          const { includeColors, includeNormals, precision } = options
          let header = \`# .PCD v0.7 - Point Cloud Data file format
VERSION 0.7
FIELDS x y z\`

          let size = \`SIZE 4 4 4\`
          let type = \`TYPE F F F\`
          let count = \`COUNT 1 1 1\`

          if (includeColors) {
            header += \` rgb\`
            size += \` 4\`
            type += \` F\`
            count += \` 1\`
          }

          if (includeNormals) {
            header += \` normal_x normal_y normal_z\`
            size += \` 4 4 4\`
            type += \` F F F\`
            count += \` 1 1 1\`
          }

          header += \`
\${size}
\${type}
\${count}
WIDTH \${points.length}
HEIGHT 1
VIEWPOINT 0 0 0 1 0 0 0
POINTS \${points.length}
DATA ascii\`

          let content = header + '\\n'
          points.forEach(point => {
            let line = \`\${point.x.toFixed(precision)} \${point.y.toFixed(precision)} \${point.z.toFixed(precision)}\`
            
            if (includeColors && point.r !== undefined) {
              // Convert RGB to packed float for PCD format
              const rgb = (Math.round(point.r) << 16) | (Math.round(point.g) << 8) | Math.round(point.b)
              line += \` \${rgb}\`
            }
            
            if (includeNormals && point.nx !== undefined) {
              line += \` \${point.nx.toFixed(precision)} \${point.ny.toFixed(precision)} \${point.nz.toFixed(precision)}\`
            }
            
            content += line + '\\n'
          })

          return content
        }

        static exportToXYZ(points, options) {
          const { includeColors, precision } = options
          let content = ''
          
          points.forEach(point => {
            let line = \`\${point.x.toFixed(precision)} \${point.y.toFixed(precision)} \${point.z.toFixed(precision)}\`
            
            if (includeColors && point.r !== undefined) {
              line += \` \${Math.round(point.r)} \${Math.round(point.g)} \${Math.round(point.b)}\`
            }
            
            content += line + '\\n'
          })

          return content
        }

        static exportToCSV(points, options) {
          const { includeColors, includeNormals, precision } = options
          let header = 'x,y,z'
          
          if (includeColors) {
            header += ',r,g,b'
          }
          
          if (includeNormals) {
            header += ',nx,ny,nz'
          }
          
          if (points.length > 0 && points[0].intensity !== undefined) {
            header += ',intensity'
          }
          
          if (points.length > 0 && points[0].confidence !== undefined) {
            header += ',confidence'
          }

          let content = header + '\\n'
          
          points.forEach(point => {
            let line = \`\${point.x.toFixed(precision)},\${point.y.toFixed(precision)},\${point.z.toFixed(precision)}\`
            
            if (includeColors && point.r !== undefined) {
              line += \`,\${Math.round(point.r)},\${Math.round(point.g)},\${Math.round(point.b)}\`
            }
            
            if (includeNormals && point.nx !== undefined) {
              line += \`,\${point.nx.toFixed(precision)},\${point.ny.toFixed(precision)},\${point.nz.toFixed(precision)}\`
            }
            
            if (point.intensity !== undefined) {
              line += \`,\${point.intensity.toFixed(precision)}\`
            }
            
            if (point.confidence !== undefined) {
              line += \`,\${point.confidence.toFixed(precision)}\`
            }
            
            content += line + '\\n'
          })

          return content
        }

        static exportToOBJ(points, options) {
          const { includeColors, precision } = options
          let content = \`# OBJ file generated by COLMAP 3D Reconstruction Platform
# Vertices: \${points.length}
\`

          // Export vertices
          points.forEach(point => {
            content += \`v \${point.x.toFixed(precision)} \${point.y.toFixed(precision)} \${point.z.toFixed(precision)}\`
            
            if (includeColors && point.r !== undefined) {
              // Normalize colors to 0-1 range for OBJ
              content += \` \${(point.r / 255).toFixed(3)} \${(point.g / 255).toFixed(3)} \${(point.b / 255).toFixed(3)}\`
            }
            
            content += '\\n'
          })

          return content
        }

        static decimatePoints(points, factor) {
          if (factor >= 1) return points
          
          const step = Math.floor(1 / factor)
          const decimated = []
          
          for (let i = 0; i < points.length; i += step) {
            decimated.push(points[i])
          }
          
          return decimated
        }

        static transformCoordinateSystem(points, fromSystem, toSystem) {
          if (fromSystem === toSystem) return points
          
          return points.map(point => {
            let { x, y, z } = point
            
            // Convert between coordinate systems
            if (fromSystem === 'opencv' && toSystem === 'opengl') {
              // OpenCV: +X right, +Y down, +Z forward
              // OpenGL: +X right, +Y up, +Z backward
              y = -y
              z = -z
            } else if (fromSystem === 'opengl' && toSystem === 'opencv') {
              y = -y
              z = -z
            } else if (fromSystem === 'colmap' && toSystem === 'opengl') {
              // COLMAP uses OpenCV convention typically
              y = -y
              z = -z
            }
            
            return { ...point, x, y, z }
          })
        }

        static filterValidPoints(points) {
          return points.filter(point => {
            return !isNaN(point.x) && !isNaN(point.y) && !isNaN(point.z) &&
                   isFinite(point.x) && isFinite(point.y) && isFinite(point.z)
          })
        }

        static calculateBoundingBox(points) {
          if (points.length === 0) return null
          
          let minX = points[0].x, maxX = points[0].x
          let minY = points[0].y, maxY = points[0].y
          let minZ = points[0].z, maxZ = points[0].z
          
          points.forEach(point => {
            minX = Math.min(minX, point.x)
            maxX = Math.max(maxX, point.x)
            minY = Math.min(minY, point.y)
            maxY = Math.max(maxY, point.y)
            minZ = Math.min(minZ, point.z)
            maxZ = Math.max(maxZ, point.z)
          })
          
          return {
            min: { x: minX, y: minY, z: minZ },
            max: { x: maxX, y: maxY, z: maxZ },
            size: { x: maxX - minX, y: maxY - minY, z: maxZ - minZ }
          }
        }
      }

      self.onmessage = function(e) {
        const { points, options } = e.data
        const startTime = performance.now()
        
        try {
          // Filter and validate points
          let processedPoints = PointCloudProcessor.filterValidPoints(points)
          
          // Apply decimation if needed
          if (options.decimationFactor && options.decimationFactor < 1) {
            processedPoints = PointCloudProcessor.decimatePoints(processedPoints, options.decimationFactor)
          }
          
          // Limit points if specified
          if (options.maxPoints && processedPoints.length > options.maxPoints) {
            const step = Math.ceil(processedPoints.length / options.maxPoints)
            processedPoints = processedPoints.filter((_, index) => index % step === 0)
          }
          
          // Transform coordinate system
          if (options.coordinateSystem !== 'colmap') {
            processedPoints = PointCloudProcessor.transformCoordinateSystem(
              processedPoints, 'colmap', options.coordinateSystem
            )
          }
          
          // Export to specified format
          let content = ''
          switch (options.format) {
            case 'ply':
              content = PointCloudProcessor.exportToPLY(processedPoints, options)
              break
            case 'pcd':
              content = PointCloudProcessor.exportToPCD(processedPoints, options)
              break
            case 'xyz':
              content = PointCloudProcessor.exportToXYZ(processedPoints, options)
              break
            case 'csv':
              content = PointCloudProcessor.exportToCSV(processedPoints, options)
              break
            case 'obj':
              content = PointCloudProcessor.exportToOBJ(processedPoints, options)
              break
            default:
              throw new Error(\`Unsupported format: \${options.format}\`)
          }
          
          const processingTime = performance.now() - startTime
          const boundingBox = PointCloudProcessor.calculateBoundingBox(processedPoints)
          
          self.postMessage({
            success: true,
            content,
            pointCount: processedPoints.length,
            processingTime,
            boundingBox,
            fileSize: new Blob([content]).size
          })
        } catch (error) {
          self.postMessage({
            success: false,
            error: error.message,
            processingTime: performance.now() - startTime
          })
        }
      }
    `
    
    const blob = new Blob([workerCode], { type: 'application/javascript' })
    this.worker = new Worker(URL.createObjectURL(blob))
  }

  /**
   * Export point cloud to specified format
   */
  async exportPointCloud(
    points: Point3D[],
    options: ExportOptions
  ): Promise<ExportResult> {
    if (!this.worker) {
      throw new Error('Worker not initialized')
    }

    return new Promise((resolve, reject) => {
      const timeout = setTimeout(() => {
        reject(new Error('Export timeout'))
      }, 60000) // 60 second timeout

      this.worker!.onmessage = (e) => {
        clearTimeout(timeout)
        const { success, content, pointCount, processingTime, boundingBox, fileSize, error } = e.data
        
        if (success) {
          // Create downloadable file
          const blob = new Blob([content], { 
            type: this.getMimeType(options.format) 
          })
          const url = URL.createObjectURL(blob)
          
          resolve({
            success: true,
            filePath: url,
            fileSize,
            pointCount,
            processingTime,
            format: options.format
          })
        } else {
          resolve({
            success: false,
            fileSize: 0,
            pointCount: 0,
            processingTime,
            format: options.format,
            error
          })
        }
      }

      this.worker!.onerror = (error) => {
        clearTimeout(timeout)
        reject(new Error(`Worker error: ${error.message}`))
      }

      // Send data to worker
      this.worker!.postMessage({ points, options })
    })
  }

  /**
   * Export from Three.js geometry
   */
  async exportFromGeometry(
    geometry: THREE.BufferGeometry,
    options: ExportOptions
  ): Promise<ExportResult> {
    const points = this.extractPointsFromGeometry(geometry)
    return this.exportPointCloud(points, options)
  }

  /**
   * Export from COLMAP reconstruction result
   */
  async exportFromColmapResult(
    reconstructionResult: any,
    options: ExportOptions
  ): Promise<ExportResult> {
    const points = reconstructionResult.points3D.map((point: any) => ({
      x: point.x,
      y: point.y,
      z: point.z,
      r: point.color?.[0] || 128,
      g: point.color?.[1] || 128,
      b: point.color?.[2] || 128
    }))
    
    return this.exportPointCloud(points, options)
  }

  /**
   * Batch export to multiple formats
   */
  async exportMultipleFormats(
    points: Point3D[],
    formats: ExportOptions['format'][],
    baseOptions: Omit<ExportOptions, 'format'>
  ): Promise<ExportResult[]> {
    const results: ExportResult[] = []
    
    for (const format of formats) {
      const options = { ...baseOptions, format }
      const result = await this.exportPointCloud(points, options)
      results.push(result)
    }
    
    return results
  }

  /**
   * Get optimal export settings based on point cloud characteristics
   */
  getOptimalExportSettings(points: Point3D[], targetUse: 'web' | 'cad' | 'analysis' | 'archival'): ExportOptions {
    const pointCount = points.length
    const hasColors = points.some(p => p.r !== undefined)
    const hasNormals = points.some(p => p.nx !== undefined)
    
    const baseOptions: ExportOptions = {
      format: 'ply',
      includeColors: hasColors,
      includeNormals: hasNormals,
      includeIntensity: false,
      precision: 6,
      coordinateSystem: 'opengl',
      compression: 'none'
    }
    
    switch (targetUse) {
      case 'web':
        return {
          ...baseOptions,
          format: pointCount > 1000000 ? 'ply' : 'obj',
          precision: 4,
          decimationFactor: pointCount > 2000000 ? 0.5 : undefined,
          maxPoints: 1000000,
          compression: pointCount > 500000 ? 'gzip' : 'none'
        }
      
      case 'cad':
        return {
          ...baseOptions,
          format: 'obj',
          precision: 6,
          coordinateSystem: 'opengl',
          includeNormals: true
        }
      
      case 'analysis':
        return {
          ...baseOptions,
          format: 'csv',
          precision: 8,
          includeIntensity: true,
          coordinateSystem: 'opencv'
        }
      
      case 'archival':
        return {
          ...baseOptions,
          format: 'ply',
          precision: 8,
          compression: 'none',
          includeColors: true,
          includeNormals: true,
          includeIntensity: true
        }
      
      default:
        return baseOptions
    }
  }

  /**
   * Validate export options
   */
  validateExportOptions(options: ExportOptions): { valid: boolean, errors: string[] } {
    const errors: string[] = []
    
    if (!['ply', 'pcd', 'xyz', 'csv', 'obj', 'las'].includes(options.format)) {
      errors.push(\`Unsupported format: \${options.format}\`)
    }
    
    if (options.precision < 1 || options.precision > 15) {
      errors.push('Precision must be between 1 and 15')
    }
    
    if (options.decimationFactor && (options.decimationFactor <= 0 || options.decimationFactor > 1)) {
      errors.push('Decimation factor must be between 0 and 1')
    }
    
    if (options.maxPoints && options.maxPoints < 1) {
      errors.push('Maximum points must be positive')
    }
    
    return {
      valid: errors.length === 0,
      errors
    }
  }

  // Helper methods
  private extractPointsFromGeometry(geometry: THREE.BufferGeometry): Point3D[] {
    const positions = geometry.getAttribute('position')
    const colors = geometry.getAttribute('color')
    const normals = geometry.getAttribute('normal')
    
    const points: Point3D[] = []
    
    for (let i = 0; i < positions.count; i++) {
      const point: Point3D = {
        x: positions.getX(i),
        y: positions.getY(i),
        z: positions.getZ(i)
      }
      
      if (colors) {
        point.r = Math.round(colors.getX(i) * 255)
        point.g = Math.round(colors.getY(i) * 255)
        point.b = Math.round(colors.getZ(i) * 255)
      }
      
      if (normals) {
        point.nx = normals.getX(i)
        point.ny = normals.getY(i)
        point.nz = normals.getZ(i)
      }
      
      points.push(point)
    }
    
    return points
  }

  private getMimeType(format: ExportOptions['format']): string {
    const mimeTypes = {
      ply: 'application/octet-stream',
      pcd: 'application/octet-stream',
      xyz: 'text/plain',
      csv: 'text/csv',
      obj: 'application/octet-stream',
      las: 'application/octet-stream'
    }
    
    return mimeTypes[format] || 'application/octet-stream'
  }

  /**
   * Cleanup resources
   */
  dispose() {
    if (this.worker) {
      this.worker.terminate()
      this.worker = null
    }
  }
}

// Export utility functions
export const PointCloudExportUtils = {
  /**
   * Download exported point cloud file
   */
  downloadFile(filePath: string, filename: string) {
    const a = document.createElement('a')
    a.href = filePath
    a.download = filename
    document.body.appendChild(a)
    a.click()
    document.body.removeChild(a)
    
    // Clean up object URL after download
    setTimeout(() => {
      URL.revokeObjectURL(filePath)
    }, 1000)
  },

  /**
   * Estimate file size before export
   */
  estimateFileSize(pointCount: number, format: ExportOptions['format'], options: Partial<ExportOptions> = {}): number {
    const { includeColors = false, includeNormals = false, precision = 6 } = options
    
    let bytesPerPoint = 0
    
    switch (format) {
      case 'ply':
      case 'xyz':
        // ASCII format estimation
        bytesPerPoint = precision * 3 + 3 // XYZ coordinates + spaces
        if (includeColors) bytesPerPoint += 12 // RGB values
        if (includeNormals) bytesPerPoint += precision * 3 + 3 // Normal vectors
        bytesPerPoint += 1 // Newline
        break
        
      case 'pcd':
        bytesPerPoint = precision * 3 + 3
        if (includeColors) bytesPerPoint += 10 // Packed RGB
        if (includeNormals) bytesPerPoint += precision * 3 + 3
        bytesPerPoint += 1
        break
        
      case 'csv':
        bytesPerPoint = precision * 3 + 2 // XYZ + commas
        if (includeColors) bytesPerPoint += 12
        if (includeNormals) bytesPerPoint += precision * 3 + 2
        bytesPerPoint += 1
        break
        
      case 'obj':
        bytesPerPoint = precision * 3 + 5 // "v " prefix + XYZ + spaces
        if (includeColors) bytesPerPoint += precision * 3 + 3
        bytesPerPoint += 1
        break
        
      default:
        bytesPerPoint = 50 // Conservative estimate
    }
    
    const baseSize = format === 'ply' ? 200 : format === 'pcd' ? 300 : 50 // Header size
    return baseSize + (pointCount * bytesPerPoint)
  },

  /**
   * Get format recommendations based on use case
   */
  getFormatRecommendations(useCase: string): {
    recommended: ExportOptions['format'][]
    reasons: string[]
  } {
    const recommendations = {
      'web-display': {
        recommended: ['ply', 'obj'] as ExportOptions['format'][],
        reasons: ['PLY for large point clouds', 'OBJ for mesh compatibility']
      },
      'scientific-analysis': {
        recommended: ['csv', 'xyz'] as ExportOptions['format'][],
        reasons: ['CSV for spreadsheet analysis', 'XYZ for custom processing']
      },
      'cad-software': {
        recommended: ['obj', 'ply'] as ExportOptions['format'][],
        reasons: ['OBJ for mesh workflows', 'PLY for detailed geometry']
      },
      'archival': {
        recommended: ['ply', 'las'] as ExportOptions['format'][],
        reasons: ['PLY for versatility', 'LAS for standardized archival']
      }
    }
    
    return recommendations[useCase] || {
      recommended: ['ply'],
      reasons: ['PLY is a versatile format for most use cases']
    }
  }
}
